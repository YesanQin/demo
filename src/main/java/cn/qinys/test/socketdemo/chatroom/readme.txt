1、实现了 客户端 单向向 服务端 发送信息的功能
      客户端创建socket作为与服务端沟通的桥梁，指定ip地址和端口
      服务端启动首先向操作系统申请一个端口，然后通过ServerSocket的实例对象中的accept方法实现监听状态，该状态是阻塞状态
      直到有客户端连接到服务端时，该方法会返回一个socket对象作为桥梁与客户端通讯？
      该通讯是基于TCP协议进行的，需要流作为基础。
      而socket中有两个方法：getOutputStream和getInputStream分别获取需要发送的数据流和发送过来的流（需要接收的流），
      该流是字节流，但在互联网传输中需要将信息按照统一的编码传输，否则会产生乱码不便与沟通。所以在此之前需要高级流（字符流输入/
      输出流）规定相应的字符集，一般使用UTF-8。最后通过缓冲字符流PrintWriter（输出）和BufferedReader（输入）将需要
      发送的字符装到流中发送和将接收到的流转换为字符显示出来。
  PrintWriter(     ,true)可以实现自动行刷新功能，其中的println方法可以自动调用flush方法将缓冲区的数据输出，
  BufferedReader可以自动行读取。
      
2、改进缺陷：1）服务端只能被一台客户端连接；      !
                                措施：首先要保证server.accept()方法时刻处于检测状态，使用while循环。每检测到一个客户端就分配一个线程
                                           独立去执行接收信息等相关操作，同时必须将产生的socket传给对应线程，socket是每个线程工作的基础。
                                           每个线程执行着原来服务器单独处理的任务，从而实现了服务器的“分身术”！
                                           此处线程的定义，线程和执行任务的相对独立。
                                           注意socket对象的流转（首先在accept处产生，作为参数并通过构造方法传递给线程执行体类的成员变量，从而
                                           可以在run方法里面被使用），其是核心，里面携带了通讯的全部信息！
         2）客户端发送的信息转到控制台控制；   !
                                措施：使用Scanner类实现
         3）多次发送，多次接收，使用循环结构；    !
                                措施：使用while死循环
         4）服务端未能识别客户端的信息；      ！
                                措施：所有的信息都在socket对象里面，通过socket的方法可以获取里面的相关信息。
                socket.getInetAddress方法获取套接字绑定的远端地址
         5）当socket不用的时候需要关闭socket释放资源；      ！
                                措施：将socket.close放入finally体
         6）服务端不能向客户端发送信息；     !
                                措施：原服务端socket只有接收输入流socket.getInputStream，现在服务端再创建一个发送输出流
                socket.getOutputStream，可以通过这个流将接收到的信息通过socket返回到客户端！
                                           原客户端socket只有发动输出流socket.getOutputStream，现在客户端再创建一个接收输入流
                socket.getInputStream，可以通过这个流接收到来自服务端发送的信息。
                                            此处：输入/输出就好像共用一条电线一样共用着socket对象，可以看出socket可以实现双向通讯，双通道！
         7）实现多个客户端同时聊天（聊天室的作用）；      ！
                                措施：需要将每个客户端发送的信息转发到每一个客户端，现在客户端与服务端已经实现了双向通讯了！服务端每个线程
                                           对应着一个客户端，接收着客户端发来的信息。现在需要共享所有客户端发送的信息相当于共享服务端中所有线程的
                                           数据。但如何共享多线程间的数据呢？首先建立一个公共区域，所有线程将接收到的信息都存储到这个公共区域。
                                           这个公共区域可以用一个List集合来表示。这就出现了多个线程对同一个集合进行存储操作而导致线程安全问题
                                           的情况。虽然集合能够实现线程安全的集合，但是集合的遍历与集合增加删除是无法达到线程安全的，因为集合的遍历
                                           是需要迭代器来实现的，而迭代器不是线程安全的！这怎么办呢？对于此处作为公共区域的集合，我们需要对其进行
                                           遍历、增加、删除操作，但由于是多线程操作，所以又要确保他们是互斥关系，这怎么办呢？重新定义三个方法，并将
                                           新定义的方法全部synchronized修饰，就实现了互斥关系！
         8）统计在线人数；    ！
                                措施：作为公用区域的集合的size就是当前在线人数！调用集合size方法时也要确保是互斥的，所以也要重新定义该方法
         9）设置昵称；
        10） 设置界面对话框；
3、问题：
      1）需要 .close关闭的对象有哪些？这些对象有什么共同点？
      2）socket只需要在服务端关闭，而不用在客户端关闭吗？
      3）虽然集合可以转换为线程安全的，但是集合的遍历与增加、删除等操作却不能形成互斥关系，why？迭代器哪里特殊了？
      
      
      输入/输出流（增加了内存与外设（硬盘、键盘、显示器、打印机、电脑）的数据联系，也是网络的基础。）
      线程（实现计算机强大能力的重要机制）
      界面（对话框、面板、控件，增强人与计算机的交互性）
      外设监听（增强人与计算机的交互）
      

         